#ifndef UTILS_H
#define UTILS_H
#include <stdbool.h>
#include "collider.h"

static inline double clamp(double val, double low, double high)
{
    const double ret = val < low ? low : val;
    return ret > high ? high : ret; 
}

void handle_collision_physics(Collider *a, Collider *b);

bool isIntersecting(Collider *obj1, Collider *obj2);

// CASIO specific utilities

#ifdef __SH4A__
#include <stdint-gcc.h>

// converts rgb-888 to rgb565
static inline uint16_t rgb565(uint8_t r, uint8_t g, uint8_t b)
{
    uint16_t red, green, blue;

    red = (r >> 3) << 11;
    green = (g >> 2) << 5;
    blue = b >> 3;

    return red | green | blue;
}

int key_pressed(int basic_keycode);

void fatal_error(char *fmt, ...);

void debug_print(char *fmt, ...);

void breakpoint(char *name);

// shady sqrt method i found on the internet
static inline float sqrt(float num)
{
    const int result = 0x1fbb4000 + (*(int*)&num >> 1);
    return *(float*)&result;
}

#ifndef NDEBUG
#define assert(condition) if (!(condition)) fatal_error("Assertion '" #condition "' failed");
#else
#define assert(condition)
#endif // NDEBUG

// fast sin and cos implementation using lookup tables
static float sini(int x)
{
    float SINTABLE[] = {0.0, 0.01745240643728351, 0.03489949670250097, 0.052335956242943835, 0.0697564737441253, 0.08715574274765817, 0.10452846326765347, 0.12186934340514748, 0.13917310096006544, 0.15643446504023087, 0.17364817766693033, 0.1908089953765448, 0.20791169081775934, 0.224951054343865, 0.24192189559966773, 0.25881904510252074, 0.27563735581699916, 0.29237170472273677, 0.3090169943749474, 0.3255681544571567, 0.3420201433256687, 0.35836794954530027, 0.374606593415912, 0.39073112848927377, 0.4067366430758002, 0.42261826174069944, 0.4383711467890774, 0.45399049973954675, 0.4694715627858908, 0.48480962024633706, 0.49999999999999994, 0.5150380749100542, 0.5299192642332049, 0.5446390350150271, 0.5591929034707469, 0.573576436351046, 0.5877852522924731, 0.6018150231520483, 0.6156614753256583, 0.6293203910498374, 0.6427876096865393, 0.6560590289905073, 0.6691306063588582, 0.6819983600624985, 0.6946583704589973, 0.7071067811865475, 0.7193398003386511, 0.7313537016191705, 0.7431448254773942, 0.754709580222772, 0.766044443118978, 0.7771459614569709, 0.788010753606722, 0.7986355100472928, 0.8090169943749475, 0.8191520442889918, 0.8290375725550417, 0.838670567945424, 0.848048096156426, 0.8571673007021123, 0.8660254037844386, 0.8746197071393957, 0.8829475928589269, 0.8910065241883678, 0.898794046299167, 0.9063077870366499, 0.9135454576426009, 0.9205048534524404, 0.9271838545667874, 0.9335804264972017, 0.9396926207859083, 0.9455185755993167, 0.9510565162951535, 0.9563047559630354, 0.9612616959383189, 0.9659258262890683, 0.9702957262759965, 0.9743700647852352, 0.9781476007338056, 0.981627183447664, 0.984807753012208, 0.9876883405951378, 0.9902680687415704, 0.992546151641322, 0.9945218953682733, 0.9961946980917455, 0.9975640502598242, 0.9986295347545738, 0.9993908270190958, 0.9998476951563913, 1.0};

    int absx = abs(x);
    
    // sin(-x) = -sin(x) 
    int sign = (x/absx);
    sign *= ( absx / 180) % 2 == 0 ? 1 : -1;

    int index = absx % 90;
    if ((absx/90)%2 == 1) index = 90 - index;

    return sign * SINTABLE[index]; 
}

static float cosi(int x)
{
    return sini(90 - x); 
}


# else // avoid issues in the SDL-Graphics project
static inline void breakpoint(char *name){};
#endif // __SH4A__


#endif